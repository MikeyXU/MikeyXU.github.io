## Michael Lanter GitHub

# 1st Blog Post

To myself, software engineering is a confusing topic because I have not yet written code to preform tasks,
except basic projects in my computer science courses.  From Machine Organization & Assembly Language, we
learned more about the bridge between software and hardware, called assembly language, which is a form of 
written software that interacts with the hardware.  I believe that this course is about using that code to
instruct our hardware to compute results and give us the desired outcome, and preform whatever task we need.
I think it is about creating, editing, and finalizing software that we write ourselves, in order to provide
a solution in apt time, using only necessary resources, with reliable methods.

# 2nd Blog Post

One of the subjects that resonated with me in the reading was the Broken Window Theory about entropy, how if 
one thing goes awry, the entire system begins to crumble if we don't work to fix it, because I've faced that 
same issue before in my code, when I tried to continue on a project, only to discover that an error I faced 
earlier became much bigger because I didn't fully fix the problem, just moreover tried to sweep it under the rug.
Along with that, another coding issue I run into that was mentionted in the reading was knowing when to stop.  
There are only so many improvements to make on a project before the code becomes more or less "spaghetti code" if
you don't stop for a minute and take a step back.  

# 3rd Blog Post

The most interesting part of the reading in this chapter for me was the error detection methods they discussed,
mostly being the analogy they used with tracer bullets.  If a certain part of your code is working, you can use
a test in there as your "tracer bullet" to show that the program is hitting that part of the code and executing
it successfully.  I like the idea of it better than prototyping because it seems more complete, checking continually
even as part of your final project, rather than just being a small part of your project that you then add to the
whole if it works, as you might do in prototyping.


