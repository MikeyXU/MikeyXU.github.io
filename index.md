## Michael Lanter GitHub

# 1st Blog Post

To myself, software engineering is a confusing topic because I have not yet written code to preform tasks,
except basic projects in my computer science courses.  From Machine Organization & Assembly Language, we
learned more about the bridge between software and hardware, called assembly language, which is a form of 
written software that interacts with the hardware.  I believe that this course is about using that code to
instruct our hardware to compute results and give us the desired outcome, and preform whatever task we need.
I think it is about creating, editing, and finalizing software that we write ourselves, in order to provide
a solution in apt time, using only necessary resources, with reliable methods.

# 2nd Blog Post

One of the subjects that resonated with me in the reading was the Broken Window Theory about entropy, how if 
one thing goes awry, the entire system begins to crumble if we don't work to fix it, because I've faced that 
same issue before in my code, when I tried to continue on a project, only to discover that an error I faced 
earlier became much bigger because I didn't fully fix the problem, just moreover tried to sweep it under the rug.
Along with that, another coding issue I run into that was mentionted in the reading was knowing when to stop.  
There are only so many improvements to make on a project before the code becomes more or less "spaghetti code" if
you don't stop for a minute and take a step back.  

# 3rd Blog Post

The most interesting part of the reading in this chapter for me was the error detection methods they discussed,
mostly being the analogy they used with tracer bullets.  If a certain part of your code is working, you can use
a test in there as your "tracer bullet" to show that the program is hitting that part of the code and executing
it successfully.  I like the idea of it better than prototyping because it seems more complete, checking continually
even as part of your final project, rather than just being a small part of your project that you then add to the
whole if it works, as you might do in prototyping.

# Assignment 6  (Chapter 2 of Mythical Man Month Book)

The reading in this book hit home hard when I realized how much time I spent coding and testing was different.  
The text recommended that at most 1/6 of your time was to be spent coding, whereas 90% of my time is spent coding.
Reading the chapter makes me realize how much I should actually be testing to ensure my code works rather than just
keep writing more code.  It also makes me realize how badly we have failed in project assingments in the past by 
attempting to just throw more man hours at a task rathe than restructuring and reorganizing.

# Assignment 7 (Chapter 4 Pragmatic Programmer)

This chapter explores the use of the DBC, or Design by Contract, methodology for writing/delivering code.  
It places emphasis on making sure you give exactly what you promise to deliver, nothing more, and nothing less.
This useful idea can easily help to make sure the requirements are clear and concise, and everything you do
is in clear parallel with the requirements.  Statements like "requires" could help immensely rather than dedicating
entire branches of a method to deal with an unwanted parameter passed in. It also for the first time ever made me 
appreciate Java coding because of the way in which can use "finally" in order to collect/destroy resources, in order
for the program to run better because the resources wont constantly be running.

# Assignment 8 (Chapter 5 Pragmatic Programmer)

Coupling made me realize why I spent so long changing various methods in projects during CS2, because I 
would have 3 "get" methods in a row like getUser().returnAmmo().useBomb(), and other similar constructs.
I would make one change in a class, and suddenly the entire program halts. The chapter also called attention
to how when we code we have a tendency to write temporal coupling, such as A has to be called before B.  This
is one program I actually have experience abusing on older Javascript games, where I could stack menus in order
to delay time in games or access unintended features.  The analogy of making a drink also helped make clear in
my mind how this idea of workflow is identical to pipelining in the computer hardware, instead of a single-cycle 
datapath.  Concurrency really just implies parallel programming in order to run faster/efficiently.

# Assignment 9 (Chapter 6 Pragmatic Programmer)

Programming deliberately hit home very quickly.  Every single point made here I think I have done at some point,
whether it be trying to write code around a pre-written class, or using programs and tech I don't understand
until I no longer have an understanding of the errors being thrown.  The section on runtime actually tremendously
helped me understand how to predict based on what is written in the code.  Refactoring brings me back to how I
realize how much I should change badly written classes, rather than trying to write new classes and methods 
to use the badly written classes.  I know that I can become defensive of my code, and refuse to change, but 
this chapter helped me realize how Im basically tripping myself up by doing that. Unit tests are also the bane of
my existence, because I suck at doing them, but I recognize how necessary they really are.

# Assignment 10 (Chapter 7 Pragmatic Programmer)

Preventing requirements from creeping up on us, might as well be called the sneak heart-attack for me.  When I 
work on a program, I like to make sure whatever I'm currently doing is as well-done as it can be.  40 hours of
work later and I've programmed a spaceship that can move with wrap around the screen, fire bullets, targeting 
missiles, and bombs, and suddenly the project is due the next day and I have 0 enemies and I'm screwed.  Happens
to all of us, right?  This book has taught me all about how I can prevent this, whether it be setting a schedule,
writing better classes/methods so I don't have to work with horrible older methods, etc.  I hope to be able to 
use these skills in my next workflow to show that I can do better than I have recently.



